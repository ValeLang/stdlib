import stdlib.stringutils.*;
import stdlib.path.*;

export Array<imm, final, str> as StrArray;
export Array<mut, vary, str> as MutStrArray;

struct Subprocess {
  command str;
  handle i64;
}

fn Subprocess(command str) Result<Subprocess, str> {
  list! = command.split(" ");
  cmd = str(list.get(0));
  newlist! = List<StrSlice>();
  enumerate(&list, (element, index){
    if (index != 0) { newlist!.add(list.get(index)); }
  });
  ret Subprocess(cmd, &newlist);
}

fn Subprocess(command str, args &List<str>) Result<Subprocess, str> {
  newlist! = List<StrSlice>();
  each (&args) (element){
    newlist!.add(slice(element));
  }
  ret Subprocess(command, &newlist);
}

fn FindProgramInPath(relative_program str) Opt<str> {
  paths = get_env_var("PATH").split(":");

  program = "";
  if (not exists(relative_program)) {
     each (&paths) (path){
      programs_at_path = iterdir(path.str());
      each (&programs_at_path) (program_at_path){
        if (program_at_path == relative_program){
          set program = path + "/" + relative_program;
        }
      }
    }
  } else {
    set program = relative_program;
  }

  if (program == "") {
    ret None<str>();
  }
  ret Some<str>(program);
}

fn Subprocess(relative_program str, args &List<StrSlice>) Result<Subprocess, str> {
  paths = get_env_var("PATH").split(":");

  maybe_program = FindProgramInPath(relative_program);

  if (maybe_program.isEmpty()) {
    panic("Unable to find program {relative_program}.");
  }
  program = (maybe_program).get();
  if (is_dir(program)) {
    panic("Unable to execute {relative_program}, is a directory.");
  }

  cmdlist! = List<str>();
  cmdlist!.add(program);
  each (&args) (element){
    cmdlist!.add(element.str());
  }

  cmd_array = cmdlist.toImmArray();

  handle = launch_command(cmd_array);
  if (handle == 0i64) {
    ret Err<Subprocess, str>("Failed to create command!");
  }

  retval = Subprocess(cmdlist.join(" "), handle);
  ret Ok<Subprocess, str>(retval);
}

fn consume_and_join<StdoutConsumer, StderrConsumer>(
  self Subprocess,
  stdout_consumer StdoutConsumer,
  stderr_consumer StderrConsumer)
int {
  running = true;
  while (running) {
    stdout_consumed_anything = false;
    stdout_consuming = true;
    while (stdout_consuming) {
      s = self.read_stdout(1000);
      if (s.len() > 0) {
        (&!stdout_consumer)(s);
        set stdout_consumed_anything = true;
      } else {
        set stdout_consuming = false;
      }
    }

    stderr_consumed_anything = false;
    stderr_consuming = true;
    while (stderr_consuming) {
      s = self.read_stderr(1000);
      if (s.len() > 0) {
        (&!stderr_consumer)(s);
        set stderr_consumed_anything = true;
      } else {
        set stderr_consuming = false;
      }
    }

    if (not stdout_consumed_anything and not stderr_consumed_anything and not self.alive()) {
      set running = false;
    }
  }

  ret join(self);
}

fn print_and_join(self Subprocess) int {
  ret consume_and_join(
    self,
    &!(stdout_chunk){ print(stdout_chunk); },
    &!(stderr_chunk){ print(stderr_chunk); });
}

struct ExecResult {
  return_code int;
  stdout str;
  stderr str;
}

fn capture_and_join(self Subprocess) ExecResult {
  stdout_builder = StringBuilder();
  stderr_builder = StringBuilder();
  return_code =
      consume_and_join(
          self,
          &!(stdout_chunk){ stdout_builder!.print(stdout_chunk); },
          &!(stderr_chunk){ stderr_builder!.print(stderr_chunk); });
  ret ExecResult(return_code, stdout_builder.str(), stderr_builder.str());
}

fn join(self Subprocess) int {
  status = join(self.handle);
  destroy(self.handle);
  ret status;
}

fn alive(self &Subprocess) bool {
  ret alive(self.handle);
}

fn read_all_stdout(self &Subprocess) str {
  builder = StringBuilder();

  running = true;
  while (running) {
    s = self.read_stdout(1000);
    println("Got some stdout, len {s.len()} alive {self.alive()}");
    builder!.print(s);
    if (s.len() == 0 and not self.alive()) {
      set running = false;
    }
  }

  ret builder.str();
}

fn read_stdout(self &Subprocess, len int) str {
  ret read_stdout(self.handle, len);
}
fn read_stderr(self &Subprocess, len int) str {
  ret read_stderr(self.handle, len);
}

fn get_env_var(name str) str extern;
fn launch_command(args Array<imm,final,str>) i64 extern;
fn write_stdin(cmd i64, s str) extern;
fn read_stdout(cmd i64, len int) str extern;
fn read_stderr(cmd i64, len int) str extern;
fn join(cmd i64) int extern;
fn alive(cmd i64) bool extern;
fn destroy(cmd i64) extern;
