import stdlib.collections.*;

fn startsWith(a str, b str) bool { startsWith(a.slice(), b.slice()) }
fn startsWith(a str, b StrSlice) bool { startsWith(a.slice(), b) }
fn startsWith(a StrSlice, b str) bool { startsWith(a, b.slice()) }
fn startsWith(a StrSlice, b StrSlice) bool {
  if (b.len() > a.len()) {
    ret false;
  }
  ret a.slice(0, b.len()) == b;
}


fn endsWith(a str, b str) bool { endsWith(a.slice(), b.slice()) }
fn endsWith(a str, b StrSlice) bool { endsWith(a.slice(), b) }
fn endsWith(a StrSlice, b str) bool { endsWith(a, b.slice()) }
fn endsWith(a StrSlice, b StrSlice) bool {
  if (b.len() > a.len()) {
    ret false;
  }
  = a.slice(a.len() - b.len(), a.len()) == b;
}


fn splice(original str, at int, removeNumChars int, insert str) str {
  before = original.slice(0, at).str();
  after = original.slice(at + removeNumChars, original.len()).str();
  ret before + insert + after;
}


fn ltrim(s str) StrSlice { ltrim(s.slice()) }
fn ltrim(s! StrSlice) StrSlice {
  whitespace = " \r\n\t";
  while (true) {
    if (s == "") {
      ret s;
    }
    if (whitespace.find(s.slice(0, 1)).isEmpty()) {
      ret s;
    }
    set s = s.slice(1, s.len());
  }
  panic("unreachable");
}
fn rtrim(s str) StrSlice { rtrim(s.slice()) }
fn rtrim(s! StrSlice) StrSlice {
  whitespace = " \r\n\t";
  while (true) {
    if (s == "") {
      ret s;
    }
    if (whitespace.find(s.slice(s.len() - 1, s.len())).isEmpty()) {
      ret s;
    }
    set s = s.slice(0, s.len() - 1);
  }
  panic("unreachable");
}

fn trim(s str) StrSlice { trim(s.slice()) }
fn trim(s! StrSlice) StrSlice { ltrim(rtrim(s)) }

fn isWhitespace(s str) bool { isWhitespace(s.slice()) }
fn isWhitespace(s! StrSlice) bool {
  while (len(s) > 0) {
    if (" \r\n\t".find(s).isEmpty()) {
      // then its not whitespace
      ret false;
    }
    set s = s.slice(1);
  }
  ret true;
}


fn ltrimnl(s str) StrSlice { ltrimnl(s.slice()) }
fn ltrimnl(s! StrSlice) StrSlice {
  while (true) {
    if (s == "") {
      ret s;
    }
    if (s.slice(0, 1) != "\n") {
      ret s;
    }
    set s = s.slice(1, s.len());
  }
  panic("unreachable");
}
fn rtrimnl(s str) StrSlice { rtrimnl(s.slice()) }
fn rtrimnl(s! StrSlice) StrSlice {
  whitespace = " \r\n\t";
  while (true) {
    if (s == "") {
      ret s;
    }
    if (s.slice(s.len() - 1, s.len()) != "\n") {
      ret s;
    }
    set s = s.slice(0, s.len() - 1);
  }
  panic("unreachable");
}

fn trimnl(s str) StrSlice { trimnl(s.slice()) }
fn trimnl(s! StrSlice) StrSlice { ltrimnl(rtrimnl(s)) }

fn int(s! StrSlice) Opt<int> {
  hasNegative! = false;
  totalSoFar! = 0;

  if (s == "") {
    ret None<int>();
  }

  while (s != "") {
    digitStr = s.slice(0, 1);

    if (digitStr == "-") {
      set hasNegative = true;
    } else {
      ascii = toAscii(digitStr);
      if (ascii < 48 or ascii >= 58) {
        ret None<int>();
      }
      digit = ascii - 48;
      set totalSoFar = totalSoFar * 10 + digit;
    }

    set s = s.slice(1);
  }

  ret Some(totalSoFar);
}

struct SplitResult {
  beforeSplit StrSlice;
  afterSplit StrSlice;
}
fn splitOnce(haystack str, needle str) Opt<SplitResult> {
  splitOnce(haystack.slice(), needle.slice())
}
fn splitOnce(haystack StrSlice, needle str) Opt<SplitResult> {
  splitOnce(haystack, needle.slice())
}
fn splitOnce(haystack str, needle StrSlice) Opt<SplitResult> {
  splitOnce(haystack.slice(), needle)
}
fn splitOnce(haystack StrSlice, needle StrSlice) Opt<SplitResult> {
  maybeOffsetAfterBegin = find(haystack, needle);
  = if (maybeOffsetAfterBegin.isEmpty()) {
      r Opt<SplitResult> = None<SplitResult>();
      = r;
    } else {
      offsetAfterBegin = maybeOffsetAfterBegin.get();
      r Opt<SplitResult> =
          Some<SplitResult>(
              SplitResult(
                  newStrSlice(
                      haystack.string,
                      haystack.begin,
                      offsetAfterBegin.begin),
                  newStrSlice(
                      haystack.string,
                      offsetAfterBegin.begin + needle.len(),
                      haystack.end)));
      = r;
    }
}


fn split(haystack str, needle str) List<StrSlice> {
  split(haystack.slice(), needle.slice())
}
fn split(haystack str, needle StrSlice) List<StrSlice> {
  split(haystack.slice(), needle)
}
fn split(haystack StrSlice, needle str) List<StrSlice> {
  split(haystack, needle.slice())
}
fn split(haystack! StrSlice, needle StrSlice) List<StrSlice> {
  // Special case first: this means they want to explode a string into
  // chars, like "abc" into "a", "b", "c"  
  if (needle == "") {
    result_parts = List<StrSlice>();
    while (haystack != "") {
      result_parts!.add(haystack.slice(0, 1));
      set haystack = haystack.slice(1, haystack.len());
    }
    ret result_parts;
  }

  // We want to maintain the invariant that
  //   something.split(needle).len() == something.count(needle).len() + 1
  // (Arbitrary decision, but seems to make sense)
  // This also means that result_parts will always have at least one entry in it.

  result_parts = List<StrSlice>();

  if (needle == "") {
    result_parts!.add("".slice());
    ret result_parts;
  }

  // For example, if we do "aabbb".split("a"), we want to take the two "a"s off
  // the start, and add two ""s to the result_parts.
  while (haystack.startsWith(needle)) {
    set haystack = haystack.slice(needle.len(), haystack.len());
    result_parts!.add("".slice());
  }

  // Similarly, if we do "bbbaa".split("a"), we want to take the "a"s off
  // the end.
  // But, we don't want to add them to the result_parts yet, we'll do that after
  // we get the stuff before it.
  // We'll just remember for now how many of them are at the end, and
  // shorten them off haystack.
  num_at_end = 0;
  while (haystack.endsWith(needle)) {
    set haystack = haystack.slice(0, haystack.len() - needle.len());
    set num_at_end = num_at_end + 1;
  }

  // For example, if we do "aaa".split("a"), the above start slicing put
  // 3 ""s into result_parts, and left us with a "". We still want another ""
  // to maintain the invariant, so we just add another one here.
  if (haystack == "") {
    result_parts!.add("".slice());
  } else {
    // If we get here, no needles are at the beginning or end, and we still
    // have a haystack.
    // For example, needle "a" and haystack "babab".
    while (haystack != "") {
      before_and_after_next_needle = haystack.splitOnce(needle);
      if (not before_and_after_next_needle.isEmpty()) {
        // There's a needle somewhere in the haystack!
        (before_next_needle, after_next_needle) = before_and_after_next_needle.get();
        // If haystack was "bacad" and needle was "a",
        // before_next_needle will contain "b" and
        // after_next_needle will contain "cad"
        result_parts!.add(before_next_needle);
        set haystack = after_next_needle; // Now haystack is "cad"
      } else {
        // If we get here, there's no more needles to be found in the haystack.
        // However, we know that there's still some hay left, for example "b".
        vassert(haystack.len() > 0);
        result_parts!.add(haystack);
        set haystack = "".slice(); // This will just end the loop
      }
    }
  }

  // Add the ""s we found at the end of the haystack when we began.
  i = 0;
  while (i < num_at_end) {
    result_parts!.add("".slice());
    set i = i + 1;
  }

  ret result_parts;
}
