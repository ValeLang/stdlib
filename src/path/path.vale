import stdlib.collections.*;

export Array<imm, final, str> as StrArray;
export Array<mut, vary, str> as MutStrArray;


struct Path {
  segments List<str>;
  //drive Opt<str>;
}
fn resolve(self &Path) Path {
  Path(resolve(self.str()))
}

fn is_dir(path &Path) bool {
  is_dir(path.str())
}

fn makeDirectory(path &Path) int {
  makeDirectory(path.str())
}

fn directory(path &Path) Path {
  result = path.clone();
  if (path.is_dir()) {
    ret result;
  }
  result.segments!.remove(result.segments.len() - 1);
  ret result;
}

fn Path(s str) Path {
  segments = List<str>();
  s.split(GetPathSeparator()).each((segment){
    segments!.add(segment.str());
  });
  // If it ends in a / there will be an empty string at the end, remove it.
  if (segments.get(segments.len() - 1) == "") {
    segments!.remove(segments.len() - 1);
  }
  vassert(segments.len() > 0);
  ret Path(segments);
}

fn name(path &Path) str {
  path.segments.get(path.segments.len() - 1)
}

fn str(path &Path) str {
  sep = GetPathSeparator();

  builder = StringBuilder();
  first = true;
  //if (not path.drive.isEmpty()) {
  //  builder!.print(path.drive.get());
  //  set first = false;
  //}
  path.segments.each((segment){
    if (not first) {
      builder!.print(sep);
    }
    builder!.print(segment);
    set first = false;
  });
  ret builder.str();
}

fn exists(path &Path) bool {
  ret exists(path.str());
}

fn ==(a &Path, b &Path) bool {
  if (a.segments.len() != b.segments.len()) {
    ret false;
  }
  i = 0;
  while (i < a.segments.len()) {
    if (a.segments.get(i) != b.segments.get(i)) {
      ret false;
    }
    set i = i + 1;
  }

  //if (a.drive.isEmpty() != b.drive.isEmpty()) {
  //  ret false;
  //}
  //if (not a.drive.isEmpty()) {
  //  if (a.drive.get() != b.drive.get()) {
  //    ret false;
  //  }
  //}
  ret true;
}
fn !=(a &Path, b &Path) bool { not (a == b) }

fn clone(self &Path) Path {
  segments = List<str>();
  self.segments.each((segment){
    segments!.add(segment);
  });
  ret Path(segments); //, self.drive);
}

fn /(path &Path, segment str) Path {
  new_path = path.clone();

  new_segments = segment.split("/");
  new_segments.each((new_segment){
    if (new_segment.len() > 0) {
      new_path.segments!.add(new_segment.str());
    }
  });

  ret new_path;
}

fn iterdir(path &Path) Array<mut, final, Path> {
  strs = iterdir(path.str());
  ret [*](strs.len(), &!{ path / strs[_] });
}


fn readFileAsString(filenameVStr str) str extern;
fn writeStringToFile(filenameVStr str, contentsVStr str) void extern;
fn GetPathSeparator() str extern;
fn is_dir(value str) bool extern;
fn is_file(value str) bool extern;
fn exists(path str) bool extern;
fn iterdir(path str) Array<imm,final,str> extern;
fn makeDirectory(path str) int extern;
fn resolve(path str) str extern;
