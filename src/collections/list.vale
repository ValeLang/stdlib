import stdlib.*;

struct List<E> rules(E Ref) {
  array! Array<mut, vary, Opt<E>>;
  size! int;
}
fn List<E>() List<E>
rules(E Ref) {
  List<E>([vary *](0, (index){ __pretend<Opt<E>>() }), 0)
}
fn len<E>(list &List<E>) int { list.size }
fn add<E>(list &!List<E>, newElement E) {
  if (list.size == list.len()) {
    newLen = if (len(&list) == 0) { 1 } else { len(&list) * 2 };
    newArray =
       [vary *](newLen, &!IFunction1<mut, int, Opt<E>>((index){
          res Opt<E> = if (index < len(&list)) {
              result Opt<E> = (mut list.array[index] = None<E>());
              = result;
            } else {
              result Opt<E> = None<E>();
              = result;
            };
          ret res;
        }));
    set list.array = newArray;
  }
  set list.array[list.size] = Some<E>(newElement);
  set list.size = list.size + 1;
}
fn get<E>(list &List<E>, index int) &E {
  a = list.array;
  = a[index].get();
}
// Perhaps we can find a way to make a function generic over permission?
fn get<E>(list &!List<E>, index int) &!E {
  a = list.array;
  = a[index]!.get();
}
fn set<E>(list &!List<E>, index int, value E) void {
  set list.array[index] = Some(value);
}
fn toArray<E>(list &List<E>) Array<mut, final, E> {
  [*](list.len(), &!(i){ list.get(i) })
}
fn toVaryArray<E>(list List<E>) Array<mut, vary, E> {
  [vary *](list.len(), &!(i){
    = (set list.array[i] = None<E>()).get();
  })
}
fn toImmArray<E>(list &List<E>) Array<imm, final, E> {
  [imm *](list.len(), &!(i){ list.get(i) })
}
// deprecate
fn toList<E>(arr &Array<_, _, E>) List<E> {
  list = List<E>();
  arr each (elem){
    list.add(elem);
  };
  = list;
}
fn List<E>(arr &Array<_, _, E>) List<E> {
  list = List<E>();
  arr each (elem){
    list.add(elem);
  };
  = list;
}

fn List<E>(arr [<_> _ * E]) List<E> {
  list =
      List<E>(
          [vary *](
              arr.len(),
              (index){
                opt Opt<E> = None<E>();
                ret opt;
              }),
          arr.len());

  i = arr.len() - 1;
  drop_into(arr, &!{
    set list.array[i] = Some<E>(_);
    set i = i - 1;
  });

  ret list;
}

fn each<E, F>(list &List<E>, func F) void {
  i! = 0;
  l = len(&list);
  while (i < l) {
    func!(list.get(i));
    set i = i + 1;
  }
}

fn each<E, F>(list &!List<E>, func F) void {
  i! = 0;
  l = len(&list);
  while (i < l) {
    func!(list.get(i));
    set i = i + 1;
  }
}

fn enumerate<E, F>(self &List<E>, func F) void {
  i! = 0;
  l = self.len();
  while (i < l) {
    func!(self.get(i), i);
    set i = i + 1;
  }
}

fn contains<E>(list &List<E>, element E) bool {
  i! = 0;
  l = len(&list);
  while (i < l) {
    if (list.get(i) == element) {
      ret true;
    }
    set i = i + 1;
  }
  ret false;
}


fn remove<E>(list &!List<E>, removeAtIndex int) E {
  if (removeAtIndex < 0) {
    panic("Can't remove at negative index!");
  }
  if (removeAtIndex >= list.size) {
    panic("Can't remove, index out of bounds!");
  }

  temp! = (mut list.array[list.size - 1] = None<E>());
  i! = list.size - 2;
  while (i >= removeAtIndex) {
    set temp = (mut list.array[i] = (mut temp = None<E>()));
    set i = i - 1;
  }

  set list.size = list.size - 1;

  ret (temp).get();
}


fn join(list &List<str>) str { join(list, "") }
fn join(list &List<str>, joiner str) str {
  combined! = StringBuilder();
  first = true;
  list.each((x){
    if (not first) {
      combined!.print(joiner);
    }
    combined!.print(x);
    set first = false;
  });
  ret combined.str();
}

fn join(list &List<StrSlice>) str { join(list, "") }
fn join(list &List<StrSlice>, joiner str) str {
  combined! = StringBuilder();
  first = true;
  list.each((x){
    if (not first) {
      combined!.print(joiner);
    }
    combined!.print(x);
    set first = false;
  });
  ret combined.str();
}

fn map<E, F>(list &List<E>, func F) List<T>
rules(T Ref, Prot("__call", (&F, E), T)) {
  result = List<T>();
  list.each({ result!.add((func)(_)); });
  ret result;
}

fn exists<E, F>(list &List<E>, func F) bool
rules(T Ref, Prot("__call", (&F, E), T)) {
  i = 0;
  while (i < list.len()) {
    if ((&!func)(list.get(i))) {
      ret true;
    }
    set i = i + 1;
  }
  ret false;
}

fn print<T>(list &List<T>) {
  print("List(");
  first! = true;
  each (&list) {
    if (not first) {
      print(", ");
    }
    set first = false;
    print(_);
  }
  print(")");
}

fn println<T>(list &List<T>) {
  print(list);
  println("");
}

struct ListBuilder<T> {
  list! List<T>;
}
fn ListBuilder<T>() ListBuilder<T> {
  ListBuilder<T>(List<T>())
}
fn add<T>(self ListBuilder<T>, newElement T) ListBuilder<T> {
  self.list!.add(newElement);
  ret self;
}
fn build<T>(self ListBuilder<T>) List<T> {
  (list) = self;
  ret list;
}
